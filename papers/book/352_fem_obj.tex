\subsection{Finite element object -- ELE-FEM}
\label{sec:ele_fem}

In this section we present the design of the finite element object, 
i.e. properties and methods, which are required to conduct the finite 
element analysis. In particular, we discuss the implementation of 
steps 2 and 3 described in  Table 
\ref{tab:alg1}, i.e., local element assembly and global assembly of system 
equation.

%In the present study, we consider the node based finite element
%and numerical integration of local finite element calculations.

%One of the advantages of object oriented programming is data
%encapsulation. In the encapsulation sense, all data, i.e.
%information, of an object are arranged to live in a scope only.
%This guarantees the safety of data within the running of
%corresponding programme as much as possible.

According to the principles of object-oriented programming, we
encapsulate common data and functionalities of finite elements into 
a base class. There are two general tasks of the finite element 
object. First, local finite element calculations and, second, 
contributions of the element to the global equation system.
%
Afterwards, we derive specific finite element objects for
different problem types (i.e. PDE types) in the framework of THM
porous media mechanics (see Fig. \ref{fig:ele_concept}).

\emph{Finite element base class:}
%
Local element calculations require the selection of specific
interpolation functions as well as their derivatives at
integration points corresponding to different element types.
Therefore, element interpolation functions are regarded as basic
items of the finite element object.
%
%We consider element interpolation functions of all kinds of
%geometric element types as global functions that are visible
%through the whole code.
%
These interpolation functions have two arguments: first, values of
shape functions or the derivative of shape functions; second,
reference points, e.g. Gauss points.
%The values of this first argument is calculated with coordinates
%of a reference point coordinates passed in through the second
%argument.
Therefore, for each kind of geometric element type, we have four
functions associated with element interpolation as

%%\small
\begin{verbatim}
  void ShapeFunctionXXXX(double*,double*);
  void ShapeFunctionHQXXXX(double*,double*);
  void GradShapeFunctionXXXX(double*,double*);
  void GradShapeFunctionHQXXXX(double*,double*);
\end{verbatim}
%%\normalsize

where \texttt{XXXX} is specifying the different geometric element
types. \texttt{ShapeFunction\-XXXX} provides linear interpolation
functions $\Sh_1$, whereas \texttt{ShapeFunctionHQXXXX} gives
quadratic interpolation functions $\Sh_2$, mentioned in section
\ref{sec:fem}. \texttt{GradShape\-FunctionXXXX} and
\texttt{GradShapeFunctionHQXXXX} offer the derivatives of the
corresponding interpolation functions $\Sh_1$ and $\Sh_2$,
respectively. Interpolation functions for all kinds of element types are declared as global functions. 
The function pointer 
\texttt{void (*VoidFuncDXCDX) (double*,double*)}
is defined to point to the addresses of the global interpolation 
functions. 
 The C++ implementation of the finite element base class \texttt{CElement} is 
given in Fig. \ref{fig:fem_root}.

\begin{figure}[htb!]
\centering
\shadowbox{
\begin{minipage}{\textwidth}
\input{352_fem_root.tex}
\end{minipage}
}
\caption{Finite element base class}
\label{fig:fem_root}
\end{figure}

Member variable, \texttt{m\_ele\_geo}, is a pointer to the
corresponding geometric element object \texttt{CElem}, which links
the finite element object to geometry. When the local assembly
takes place for an element, the instance of this element is
obtained by finite element object with its member function,
\texttt{void Config(CElem\* m\_ele\_geo)}. With this, the finite
element object has all geometrical and topological properties such as geometric type,
coordinate nodes, neighbors for local element calculation.

%Element configuration is based on the geometric element type. The
%C++ implementation of the \texttt{Config} function is presented in
%Fig. \ref{fig:fem_num}.
%
%\input{code/fem_num}

Different weak forms arise from the different governing equations
of flow problem, heat transport problem and mechanical problem
(eqn. (\ref{eq:wkmass}), (\ref{eq:wkhTmass}) and
(\ref{eq:wkstress})). This requires different element level
computations for the specific problem. Since root finite element
object provides the basic numerical functionality, we can use 
this object directly for the benefit of the polymorphism mechanism
of object oriented programming.

